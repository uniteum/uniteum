{
    "language": "Solidity",
    "sources": {
        "src/Unit.sol": {
            "content": "// SPDX-License-Identifier: LicenseRef-Uniteum\n\npragma solidity ^0.8.30;\n\nimport {IUnit, IMigratable, IERC20} from \"./IUnit.sol\";\nimport {CloneERC20, Prototype} from \"./CloneERC20.sol\";\nimport {Units, Term} from \"./Units.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {TransientSlot} from \"@openzeppelin/contracts/utils/TransientSlot.sol\";\n\n/**\n * @title IUnit — A universal liquidity system based on symbolic units.\n * See {IUnit} for details.\n */\ncontract Unit is CloneERC20, IUnit {\n    using Units for *;\n    using SafeERC20 for IERC20;\n    using TransientSlot for *;\n\n    /// @notice The ERC-20 symbol for the central 1 token.\n    string public constant ONE_SYMBOL = \"1\";\n\n    /// @notice The ERC-20 symbol for the central 1 token.\n    string public constant NAME_PREFIX = \"Uniteum 0.1 \";\n\n    /// @notice The total original supply of {1} minted.\n    /// @dev The total supply of {1} will never exceed this value.\n    uint256 public immutable ONE_MINTED;\n\n    /// @notice The central 1 unit.\n    Unit private immutable ONE = this;\n\n    /// @inheritdoc IUnit\n    IUnit public reciprocal;\n\n    /// @inheritdoc IUnit\n    IERC20 public anchor;\n\n    /// @inheritdoc IUnit\n    function one() public view returns (IUnit) {\n        return ONE;\n    }\n\n    /// @inheritdoc IUnit\n    function invariant(uint256 u, uint256 v) public pure returns (uint256 w) {\n        w = Math.sqrt(u * v);\n    }\n\n    /// @inheritdoc IUnit\n    function invariant() public view notOne returns (uint256 u, uint256 v, uint256 w) {\n        u = totalSupply();\n        v = reciprocal.totalSupply();\n        w = invariant(u, v);\n    }\n\n    /// @inheritdoc IUnit\n    function invariant(IUnit V) public view returns (IUnit W, uint256 u, uint256 v, uint256 w) {\n        if (address(V) == address(this)) {\n            revert DuplicateUnits();\n        } else if (address(V) == address(reciprocal)) {\n            W = one();\n            (u, v, w) = invariant();\n        } else {\n            (W,) = product(V);\n            u = this.balanceOf(address(W));\n            v = V.balanceOf(address(W));\n            w = invariant(u, v);\n        }\n    }\n\n    /// @inheritdoc IUnit\n    /// @dev Revert if called on 1 via call to invariant().\n    function forgeQuote(int256 du, int256 dv) public view returns (int256 dw) {\n        (uint256 u0, uint256 v0, uint256 w0) = invariant();\n\n        uint256 u1 = add(this, u0, du);\n        uint256 v1 = add(reciprocal, v0, dv);\n        uint256 w1 = invariant(u1, v1);\n\n        // forge-lint: disable-next-line(unsafe-typecast)\n        dw = int256(w0) - int256(w1);\n        // Double dw if no anchor tokens are involved to keep the invariant balanced.\n        if (address(anchor) == address(0) && address(reciprocal.anchor()) == address(0)) {\n            dw *= 2;\n        }\n    }\n\n    /// @inheritdoc IUnit\n    /// @dev Revert if called on 1 via call to invariant().\n    function forgeQuote(IUnit V, int256 du, int256 dv) public view returns (IUnit W, int256 dw) {\n        if (address(V) == address(reciprocal)) {\n            W = one();\n            dw = forgeQuote(du, dv);\n        } else {\n            uint256 u0;\n            uint256 v0;\n            uint256 w0;\n            (W, u0, v0, w0) = invariant(V);\n\n            uint256 u1 = add(this, u0, -du);\n            uint256 v1 = add(V, v0, -dv);\n            uint256 w1 = invariant(u1, v1);\n\n            // forge-lint: disable-next-line(unsafe-typecast)\n            dw = 2 * (int256(w1) - int256(w0));\n        }\n    }\n\n    /// @inheritdoc IUnit\n    /// @dev This function must be non-reentrant to thwart malicious anchor tokens.\n    /// @dev Revert if called on 1 via call to invariant().\n    function forge(int256 du, int256 dv) external nonReentrant returns (int256 dw) {\n        dw = forgeQuote(du, dv); // Also check for notOne.\n        // forge-lint: disable-next-line(unsafe-typecast)\n        if (du < 0) this.__burn(msg.sender, uint256(-du));\n        // forge-lint: disable-next-line(unsafe-typecast)\n        if (dv < 0) Unit(address(reciprocal)).__burn(msg.sender, uint256(-dv));\n        // forge-lint: disable-next-line(unsafe-typecast)\n        if (dw < 0) ONE.__burn(msg.sender, uint256(-dw));\n        // forge-lint: disable-next-line(unsafe-typecast)\n        if (du > 0) this.__mint(msg.sender, uint256(du));\n        // forge-lint: disable-next-line(unsafe-typecast)\n        if (dv > 0) Unit(address(reciprocal)).__mint(msg.sender, uint256(dv));\n        // forge-lint: disable-next-line(unsafe-typecast)\n        if (dw > 0) ONE.__mint(msg.sender, uint256(dw));\n        emit Forge(msg.sender, this, du, dv, dw);\n    }\n\n    //// @inheritdoc IUnit\n    /// @dev This function must be non-reentrant to thwart malicious anchor tokens.\n    /// @dev Revert if called on 1 via call to invariant().\n    function forge(IUnit V, int256 du, int256 dv) external nonReentrant returns (IUnit W, int256 dw) {\n        (W, dw) = forgeQuote(V, du, dv); // Also check for notOne.\n        // forge-lint: disable-next-line(unsafe-typecast)\n        if (du < 0) this.__transfer(msg.sender, address(W), uint256(-du));\n        // forge-lint: disable-next-line(unsafe-typecast)\n        if (dv < 0) Unit(address(V)).__transfer(msg.sender, address(W), uint256(-dv));\n        // forge-lint: disable-next-line(unsafe-typecast)\n        if (dw < 0) Unit(address(W)).__burn(msg.sender, uint256(-dw));\n        // forge-lint: disable-next-line(unsafe-typecast)\n        if (du > 0) this.__transfer(address(W), msg.sender, uint256(du));\n        // forge-lint: disable-next-line(unsafe-typecast)\n        if (dv > 0) Unit(address(V)).__transfer(address(W), msg.sender, uint256(dv));\n        // forge-lint: disable-next-line(unsafe-typecast)\n        if (dw > 0) Unit(address(W)).__mint(msg.sender, uint256(dw));\n        emit Forge(msg.sender, this, du, dv, dw);\n    }\n\n    /**\n     * @notice Burn units of the holder.\n     * @dev - Only Units with the same 1 can call this function.\n     * @param from The holder of the burned units.\n     * @param to The holder of the burned units.\n     * @param units The number of units to burn.\n     */\n    function __transfer(address from, address to, uint256 units) public onlyUnit {\n        _transfer(from, to, units);\n    }\n\n    /**\n     * @notice Burn units of the holder.\n     * @dev - Only Units with the same 1 can call this function.\n     * @param holder The holder of the burned units.\n     * @param units The number of units to burn.\n     */\n    function __burn(address holder, uint256 units) public onlyUnit {\n        _burn(holder, units);\n    }\n\n    /**\n     * @notice Mint units for the holder.\n     * @dev - Only Units with the same 1 can call this function.\n     * @param holder The recipient of the minted units.\n     * @param units The number of units to mint.\n     */\n    function __mint(address holder, uint256 units) public onlyUnit {\n        // If this Unit wraps an external token, get wrapped tokens from the holder.\n        if (address(anchor) != address(0)) {\n            anchor.safeTransferFrom(holder, address(this), units);\n        }\n        _mint(holder, units);\n    }\n\n    /**\n     * @notice Safely computes an updated supply of tokens and reverts if the supply would be negative.\n     * @param U The unit whose supply is being calculated. For errors only.\n     * @param u0 The current supply of U.\n     * @param du The change in the supply of U.\n     * @return u1 The updated supply of U.\n     */\n    function add(IUnit U, uint256 u0, int256 du) private pure returns (uint256 u1) {\n        // forge-lint: disable-next-line(unsafe-typecast)\n        int256 u = int256(u0) + du;\n        if (u < 0) {\n            revert NegativeSupply(U, u);\n        }\n        // forge-lint: disable-next-line(unsafe-typecast)\n        u1 = uint256(u);\n    }\n\n    /**\n     * @dev Only one() can call this method.\n     * @param canonical expression defining the unit.\n     */\n    function __initialize(string memory canonical) internal {\n        _symbol = canonical;\n        _name = string.concat(NAME_PREFIX, canonical);\n        Term[] memory terms = canonical.parseTerms();\n        if (terms.length == 1) {\n            anchor = IERC20(terms[0].anchor());\n        }\n        (address reciprocalAddress,) = __clone(bytes(terms.reciprocal().sortAndMerge().symbol()));\n        reciprocal = IUnit(reciprocalAddress);\n    }\n\n    /// @inheritdoc Prototype\n    function __initialize(bytes memory initData) public virtual override onlyPrototype {\n        __initialize(string(initData));\n    }\n\n    /// @inheritdoc IUnit\n    function product(string memory expression) public view returns (IUnit unit, string memory canonical) {\n        Term[] memory terms = symbol().parseTerms().product(expression.parseTerms().sortAndMerge());\n        if (terms.length > 0) {\n            terms = terms.sortAndMerge();\n        }\n        canonical = terms.symbol();\n        if (terms.length == 0) {\n            unit = one();\n        } else {\n            (address unitAddress,) = __predict(bytes(canonical));\n            unit = IUnit(unitAddress);\n        }\n    }\n\n    /// @inheritdoc IUnit\n    function multiply(string memory expression) public returns (IUnit unit) {\n        string memory canonical;\n        (unit, canonical) = product(expression);\n        if (address(unit).code.length == 0) {\n            __clone(bytes(canonical));\n        }\n    }\n\n    /// @inheritdoc IUnit\n    function anchoredSymbol(IERC20 token) public pure returns (string memory s) {\n        s = address(token).withExponent(Units.ONE_RATIONAL_8).symbol();\n    }\n\n    /// @inheritdoc IUnit\n    function anchoredPredict(IERC20 token) external view returns (IUnit unit, string memory canonical) {\n        (unit, canonical) = product(anchoredSymbol(token));\n    }\n\n    /// @inheritdoc IUnit\n    function anchored(IERC20 token) external returns (IUnit unit) {\n        unit = multiply(anchoredSymbol(token));\n    }\n\n    /// @dev Mapping of multipliers to their product units.\n    mapping(IUnit => IUnit) private _products;\n\n    /// @inheritdoc IUnit\n    function product(IUnit multiplier) public view returns (IUnit unit, string memory canonical) {\n        unit = _products[multiplier];\n        if (address(unit) != address(0)) {\n            canonical = unit.symbol();\n        } else {\n            (unit, canonical) = product(multiplier.symbol());\n        }\n    }\n\n    /// @inheritdoc IUnit\n    function multiply(IUnit multiplier) public returns (IUnit unit) {\n        unit = _products[multiplier];\n        if (address(unit) == address(0)) {\n            unit = multiply(multiplier.symbol());\n            _products[multiplier] = unit;\n        }\n    }\n\n    modifier onlyUnit() {\n        _onlyUnit();\n        _;\n    }\n\n    function _onlyUnit() private view {\n        // Revert if the caller does not have the same address as predicted by its hash.\n        // Prevent malicious actors from calling protected functions.\n        if ((msg.sender != PROTOTYPE) && (!Prototype(PROTOTYPE).isClone(msg.sender))) {\n            revert Unauthorized();\n        }\n    }\n\n    modifier onlyOne() {\n        _onlyOne();\n        _;\n    }\n\n    function _onlyOne() private view {\n        if (this != one()) {\n            revert FunctionNotCalledOnOne();\n        }\n    }\n\n    modifier notOne() {\n        _notOne();\n        _;\n    }\n\n    function _notOne() private view {\n        if (this == one()) {\n            revert FunctionCalledOnOne();\n        }\n    }\n\n    // The following reentrancy code was modified from openzeppelin.storage.ReentrancyGuardTransient\n    // It uses transient boolean storage on {one()} to prevent reentrancy on all units during a transaction.\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ReentrancyGuardTransient\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant REENTRANCY_GUARD_STORAGE =\n        0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ONE.__nonReentrantBefore();\n    }\n\n    function _nonReentrantAfter() private {\n        ONE.__nonReentrantAfter();\n    }\n\n    function __nonReentrantBefore() public onlyOne {\n        if (REENTRANCY_GUARD_STORAGE.asBoolean().tload()) {\n            revert ReentryForbidden();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        REENTRANCY_GUARD_STORAGE.asBoolean().tstore(true);\n    }\n\n    function __nonReentrantAfter() public onlyOne {\n        REENTRANCY_GUARD_STORAGE.asBoolean().tstore(false);\n    }\n\n    IERC20 public immutable UPSTREAM;\n\n    /// @inheritdoc IMigratable\n    function migrate(uint256 units) external onlyOne {\n        UPSTREAM.safeTransferFrom(msg.sender, address(this), units);\n        _mint(msg.sender, units);\n        emit Migrate(msg.sender, units);\n    }\n\n    /// @inheritdoc IMigratable\n    function unmigrate(uint256 units) external onlyOne {\n        _burn(msg.sender, units);\n        UPSTREAM.safeTransferFrom(address(this), msg.sender, units);\n        emit Unmigrate(msg.sender, units);\n    }\n\n    constructor(IERC20 upstream) CloneERC20(ONE_SYMBOL, ONE_SYMBOL) {\n        reciprocal = this;\n        _symbol = ONE_SYMBOL;\n        _name = string.concat(NAME_PREFIX, ONE_SYMBOL);\n        UPSTREAM = upstream;\n        emit UnitCreate(this, anchor, bytes32(0), _symbol);\n    }\n}\n"
        },
        "src/IUnit.sol": {
            "content": "// SPDX-License-Identifier: LicenseRef-Uniteum\n\npragma solidity ^0.8.30;\n\nimport {IERC20Metadata, IERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IMigratable} from \"./IMigratable.sol\";\n\n/**\n * @title IUnit — A universal liquidity system based on symbolic units.\n * @notice A Unit (U) is an ERC-20 token with built-in liquidity via reciprocal minting/burning.\n * The identity unit {one()} aka {1} is the universal liquidity token around which a unit and its reciprocal pivot.\n * Units support a {forge} operation that mints/burns combinations of 1, U, and 1/U to maintain a constant product invariant.\n * If a unit goes up in price, its reciprocal goes down, and vice versa.\n * Some units are anchored to external ERC-20 tokens, to integrate the system with the broader ERC-20 ecosystem.\n *\n * A Unit symbolically represents a unit of measure, such as a a physical dimension, abstract quantity, linked ERC-20 token, or compound units.\n * It supports rational powers of base units and algebraic composition such as product and reciprocal.\n * A base unit has two varieties: anchored or unanchored.\n *\n * An anchored unit is a 1:1 custodial owner of an external ERC-20 token\n *   Its symbol is the Ethereum address of the external token prefixed with '$'.\n *   Examples: $0xdAC17F958D2ee523a2206206994597C13D831ec7 (USDT), $0x1f9840a85d5af5bf1d1762f925bdaddc4201f984 (UNI)\n *\n * An unanchored base unit has no associated external token.\n *   Its symbol is an unbroken sequence of the following characters: 'a'-'z', 'A'-'Z', '0'-'9', '_', '-', '.'\n *   Symbols are case sensitive and are limited to 30 characters.\n *   Examples: kg, KG, kG, Kg, m, s, MSFT, USD, _, -, ., example.com, QmFzZTY0IGVuY29kZWQgdW5pdA\n *   Note: unanchored base units have no inherent connection to real world entities.\n *         MSFT IS NOT inherently connected to Microsoft stock.\n *         kg IS NOT inherently connected to the concept of a kilogram.\n *\n * A pure power unit, aka term, is a base unit raised to a power using a combination of '^' and '1/' notation\n *   Division in exponents uses the '\\' character instead of the '/ to simplify parsing\n *   Powers can be rational fractions represented using '\\' for division in the exponent\n *     Examples: kg^2, 1/s, 1/m^2, 1/T^1\\4, 1/$0xdAC17F958D2ee523a2206206994597C13D831ec7^3\\7\n *   Operations within terms:\n *     ^ power\n *     \\ divide\n * Compound units are products of pure power units separated by '*' or '/'\n *   Examples: kg*m/s^2, MSFT/USD, 1/foo^2\\5/bar^7\\9\n *   Operations combining terms:\n *     * multiply\n *     / divide\n *\n * @dev Version scope (v1)\n * - Value constraints exist between a Unit and its reciprocal, and between an anchored token and its anchor.\n * - Powers/exponentials (e.g., constraining value across A and A^k like power perpetuals) are\n *   not enforced; this may be future work.\n *\n * @dev Non-promissory hypotheses (for readers' intuition; not guarantees)\n * - As anchored collateral and unanchored participation grow, the value of \"1\" may tend to reflect\n *   aggregate system value (anchored + unanchored).\n * - With many diverse Units, \"1\" may exhibit reduced volatility via diversification effects.\n *\n * @dev Safety\n * - Anchored units are custodial: underlying tokens are held by this contract.\n * - This system uses no price oracles or off-chain dependencies.\n *\n * @dev Reentrancy Protection\n * All state-changing functions use a transient reentrancy guard stored on the \"1\" unit\n * per EIP-1153. This protects against malicious anchor token callbacks.\n * @custom:security Uses transient storage; requires EVM version Cancun or later\n *\n * @dev Internal Function Naming Convention\n * Functions prefixed with __ are restricted to calls from other Units in the same system (same ONE).\n * These are used for cross-unit operations during forge.\n */\ninterface IUnit is IERC20Metadata, IMigratable {\n    /**\n     * @notice Compute the constant product invariant for a reciprocal pair.\n     * The implied price for the unit is w/u, and w/v for its reciprocal.\n     * @param u Total supply of a unit.\n     * @param v Total supply of its reciprocal.\n     * @return w sqrt(u * v).\n     */\n    function invariant(uint256 u, uint256 v) external view returns (uint256 w);\n\n    /**\n     * @notice Return the constant product invariant for a reciprocal pair.\n     * @return u Total supply of the unit.\n     * @return v Total supply of its reciprocal.\n     * @return w sqrt(u * v).\n     */\n    function invariant() external view returns (uint256 u, uint256 v, uint256 w);\n\n    /**\n     * @notice Return the constant product invariant for a pair.\n     * @param V The invariant pair for this unit.\n     * @return W Product of this unit and V.\n     * @return u Total supply of the unit.\n     * @return v Total supply of its reciprocal.\n     * @return w sqrt(u * v).\n     */\n    function invariant(IUnit V) external view returns (IUnit W, uint256 u, uint256 v, uint256 w);\n\n    /**\n     * @notice Compute the change of the caller's 1 balance that would result from forging this unit.\n     *\n     * @dev Invariant solver for the forge operation.\n     * Given signed changes to the caller's balances of the unit `du` and its reciprocal `dv`,\n     * this function computes the signed change to 1 `dw` required to preserve the\n     * constant-product relationship across the triad (U, 1/U, 1).\n     *\n     * Sign convention:\n     *  - Positive values mint units to the caller.\n     *  - Negative values burn units from the caller.\n     *\n     * @param V Other unit.\n     * @param du Signed change of the caller's unit balance.\n     * @param dv Signed change of the caller's reciprocal balance.\n     * @return W Product of this unit and V.\n     * @return dw Signed change of caller's 1 balance.\n     */\n    function forgeQuote(IUnit V, int256 du, int256 dv) external view returns (IUnit W, int256 dw);\n\n    /**\n     * @notice Compute the change of the caller's 1 balance that would result from forging this unit.\n     *\n     * @dev Invariant solver for the forge operation.\n     * Given signed changes to the caller's balances of the unit `du` and its reciprocal `dv`,\n     * this function computes the signed change to 1 `dw` required to preserve the\n     * constant-product relationship across the triad (U, 1/U, 1).\n     *\n     * Sign convention:\n     *  - Positive values mint units to the caller.\n     *  - Negative values burn units from the caller.\n     *\n     * @param du Signed change of the caller's unit balance.\n     * @param dv Signed change of the caller's reciprocal balance.\n     * @return dw Signed change of caller's 1 balance.\n     */\n    function forgeQuote(int256 du, int256 dv) external view returns (int256 dw);\n\n    /**\n     * @notice Mint/burn combinations of this unit, its reciprocal and 1.\n     * @dev\n     * Uses {forgeQuote} to compute the necessary deltas to maintain the invariant,\n     * then mints/burns the corresponding amounts of du, dv, and dw for the caller.\n     * To mint an anchored unit, even if it participates as the reciprocal,\n     * the caller must approve transferring the anchor token to the unit:\n     *     u.anchor().approve(address(u)), uint256(du));\n     *\n     * @param V Other unit.\n     * @param du Signed delta of the unit U.\n     * @param dv Signed delta of the unit 1/U.\n     * @return W Product of this unit and V.\n     * @return dw Signed delta of 1 minted/burned for the caller.\n     */\n    function forge(IUnit V, int256 du, int256 dv) external returns (IUnit W, int256 dw);\n\n    /**\n     * @notice Mint/burn combinations of this unit, its reciprocal and 1.\n     * @dev\n     * Uses {forgeQuote} to compute the necessary deltas to maintain the invariant,\n     * then mints/burns the corresponding amounts of du, dv, and dw for the caller.\n     * To mint an anchored unit, even if it participates as the reciprocal,\n     * the caller must approve transferring the anchor token to the unit:\n     *     u.anchor().approve(address(u)), uint256(du));\n     *\n     * @param du Signed delta of the unit U.\n     * @param dv Signed delta of the unit 1/U.\n     * @return dw Signed delta of 1 minted/burned for the caller.\n     */\n    function forge(int256 du, int256 dv) external returns (int256 dw);\n\n    /**\n     * @notice Predict the address of the IUnit resulting from multiplying by a symbolic expression.\n     * @dev View-only; does not create the unit. Use {multiply} to create if needed.\n     * @param expression a string representation of the unit.\n     * @return unit the IUnit for the given expression.\n     * @return symbol the canonical form of the string representation of the unit.\n     */\n    function product(string memory expression) external view returns (IUnit unit, string memory symbol);\n\n    /**\n     * @notice Create a new unit if it does not exist, or return existing unit.\n     * @dev Creates the unit by multiplying this unit with the expression.\n     * @param expression a string representation of the unit to multiply by.\n     * @return unit the IUnit with the resulting symbol.\n     */\n    function multiply(string memory expression) external returns (IUnit unit);\n\n    /**\n     * @notice Predict the unit resulting from multiplying this unit by another unit.\n     * @dev View-only; uses cached product mapping when available, otherwise computes from symbols.\n     * Does not create the unit. Use {multiply} to create if needed.\n     * @param multiplier The right-hand unit operand.\n     * @return unit The IUnit representing the product.\n     * @return symbol the canonical form of the string representation of the unit.\n     */\n    function product(IUnit multiplier) external view returns (IUnit unit, string memory symbol);\n\n    /**\n     * @notice Create or return the product of this unit with another unit.\n     * @dev Creates the product unit if it doesn't exist, caches the mapping for future calls.\n     * @param multiplier The right-hand unit operand.\n     * @return product The new or existing IUnit representing the product.\n     */\n    function multiply(IUnit multiplier) external returns (IUnit product);\n\n    /**\n     * @notice Predict the address of an anchored unit.\n     * @param token to be anchored to.\n     * @return unit the IUnit anchored to the given token.\n     * @return symbol the canonical form of the string representation of the unit.\n     */\n    function anchoredPredict(IERC20 token) external view returns (IUnit unit, string memory symbol);\n\n    /**\n     * @notice Create an anchored unit if it does not exist.\n     * @param token to be anchored to.\n     * @return unit the IUnit anchored to the given token.\n     */\n    function anchored(IERC20 token) external returns (IUnit unit);\n\n    /**\n     * @notice Return the symbol for an anchored token.\n     *   Example: $0xdAC17F958D2ee523a2206206994597C13D831ec7 (USDT)\n     * @param token to be anchored to.\n     * @return symbol the canonical form of the string representation of the unit.\n     */\n    function anchoredSymbol(IERC20 token) external pure returns (string memory symbol);\n\n    /**\n     * @notice The identity unit \"1\".\n     * @dev Also the implementation and deployer for all other units, which are clones.\n     */\n    function one() external view returns (IUnit);\n\n    /**\n     * @return The IUnit representing the reciprocal of this unit.\n     */\n    function reciprocal() external view returns (IUnit);\n\n    /**\n     * @return The external token, if any, anchored to this unit.\n     */\n    function anchor() external view returns (IERC20);\n\n    /**\n     * @dev Revert when called with duplicate units.\n     */\n    error DuplicateUnits();\n\n    /**\n     * @dev Revert when called on 1.\n     */\n    error FunctionCalledOnOne();\n\n    /**\n     * @dev Revert when called on anything but 1.\n     */\n    error FunctionNotCalledOnOne();\n\n    /**\n     * @dev Revert when a negative supply would result from an operation.\n     * @param unit The unit that would have negative supply.\n     * @param supply The calculated negative supply value.\n     */\n    error NegativeSupply(IUnit unit, int256 supply);\n\n    /**\n     * @dev Reentrant calls are forbidden.\n     */\n    error ReentryForbidden();\n\n    /**\n     * @notice Emit on unit creation.\n     * @param unit The created unit.\n     * @param hash used to compute the address of the unit.\n     * @param symbol The symbol of the the unit.\n     */\n    event UnitCreate(IUnit indexed unit, IERC20 indexed anchor, bytes32 indexed hash, string symbol);\n\n    /**\n     * @notice Emit when a holder calls forge.\n     * @param holder The address whose balances were updated.\n     * @param unit   The unit doing the forge.\n     * @param du     signed change to the holder's balance of the unit.\n     * @param dv     signed change to the holder's balance of the reciprocal unit.\n     * @param dw     signed change to the holder's balance of 1.\n     */\n    event Forge(address indexed holder, IUnit indexed unit, int256 du, int256 dv, int256 dw);\n\n    /**\n     * @notice Emitted when tokens are migrated into the system.\n     * @param user The address migrating tokens.\n     * @param amount Amount of tokens migrated.\n     */\n    event Migrate(address indexed user, uint256 amount);\n\n    /**\n     * @notice Emitted when tokens are unmigrated from the system.\n     * @param user The address unmigrating tokens.\n     * @param amount Amount of tokens unmigrated.\n     */\n    event Unmigrate(address indexed user, uint256 amount);\n}\n"
        },
        "src/CloneERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\nimport {Prototype} from \"./Prototype.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title CloneERC20\n * @notice ERC-20 base contract with support for minimal proxy cloning (EIP-1167).\n * @dev\n * Combines OpenZeppelin's ERC20 standard implementation with the Prototype\n * cloning pattern, enabling gas-efficient deployment of multiple ERC-20 tokens\n * that share the same implementation logic but maintain isolated storage.\n *\n * **Key Design Pattern:**\n * Standard ERC-20 implementations store name and symbol as immutables set during\n * construction. This prevents cloning because minimal proxies (EIP-1167) delegate\n * all logic via DELEGATECALL and cannot have their own constructor parameters.\n *\n * CloneERC20 solves this by:\n * 1. Storing name and symbol in regular storage variables (_name, _symbol)\n * 2. Overriding name() and symbol() accessors to read from storage\n * 3. Allowing these values to be set during __initialize() on each clone\n *\n * **Usage Pattern:**\n * ```solidity\n * // 1. Deploy prototype\n * MyToken prototype = new MyToken(\"PROTO\", \"PROTO\");\n *\n * // 2. Create clones with custom metadata\n * bytes memory initData = abi.encode(creator, \"Token A\", \"TKA\");\n * (address tokenA, ) = prototype.__clone(initData);\n *\n * initData = abi.encode(creator, \"Token B\", \"TKB\");\n * (address tokenB, ) = prototype.__clone(initData);\n *\n * // 3. Each clone has its own name/symbol but shares logic\n * assert(MyToken(tokenA).name() == \"Token A\");\n * assert(MyToken(tokenB).name() == \"Token B\");\n * ```\n *\n * **Storage Layout:**\n * Each clone maintains its own:\n * - _name: Token name (settable during initialization)\n * - _symbol: Token symbol (settable during initialization)\n * - _balances: Mapping of account balances (ERC20 inherited)\n * - _allowances: Mapping of allowances (ERC20 inherited)\n * - _totalSupply: Total token supply (ERC20 inherited)\n *\n * **Why Empty String Constructor:**\n * The ERC20 base constructor is passed empty strings because:\n * - Those values would only affect the prototype contract itself\n * - Clones override name() and symbol() to read from their own storage\n * - This prevents confusion between prototype metadata and clone metadata\n *\n * **Inheritance Chain:**\n * CloneERC20 → ERC20 (OpenZeppelin) + Prototype (factory pattern)\n *\n * @author Paul Reinholdtsen (reinholdtsen.eth)\n */\nabstract contract CloneERC20 is ERC20, Prototype {\n    // ============ State Variables ============\n\n    /**\n     * @dev Token name, settable during clone initialization.\n     *\n     *      Unlike standard ERC-20 implementations where name is immutable,\n     *      this is stored in a regular storage slot to allow each clone to\n     *      have its own name without requiring constructor parameters.\n     *\n     *      Set during __initialize() on each clone.\n     */\n    string internal _name;\n\n    /**\n     * @dev Token symbol, settable during clone initialization.\n     *\n     *      Unlike standard ERC-20 implementations where symbol is immutable,\n     *      this is stored in a regular storage slot to allow each clone to\n     *      have its own symbol without requiring constructor parameters.\n     *\n     *      Set during __initialize() on each clone.\n     */\n    string internal _symbol;\n\n    // ============ Constructor ============\n\n    /**\n     * @notice Initializes the prototype implementation with name and symbol.\n     * @dev\n     * **Important:** These parameters only affect the prototype contract itself,\n     * NOT the clones. Each clone sets its own _name and _symbol during __initialize().\n     *\n     * The ERC20 base constructor receives empty strings (\"\", \"\") because:\n     * 1. We override name() and symbol() to read from storage instead\n     * 2. The prototype's metadata is rarely used (clones are what matter)\n     * 3. This keeps the pattern consistent across prototype and clones\n     *\n     * **For derived contracts:**\n     * Pass descriptive metadata for the prototype (often \"PROTO\" or similar)\n     * to distinguish it from actual clone instances.\n     *\n     * @param name_ Name for the prototype implementation.\n     * @param symbol_ Symbol for the prototype implementation.\n     */\n    constructor(string memory name_, string memory symbol_) ERC20(\"\", \"\") {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    // ============ ERC-20 Metadata Overrides ============\n\n    /**\n     * @notice Returns the name of the token.\n     * @dev Overrides ERC20.name() to read from storage instead of immutables.\n     *\n     *      **On the prototype:** Returns the name set in constructor.\n     *      **On clones:** Returns the name set during __initialize().\n     *\n     *      This allows each clone to have distinct metadata while sharing\n     *      the same implementation logic.\n     *\n     * @return The token name.\n     */\n    function name() public view virtual override(ERC20) returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @notice Returns the symbol of the token.\n     * @dev Overrides ERC20.symbol() to read from storage instead of immutables.\n     *\n     *      **On the prototype:** Returns the symbol set in constructor.\n     *      **On clones:** Returns the symbol set during __initialize().\n     *\n     *      This allows each clone to have distinct metadata while sharing\n     *      the same implementation logic.\n     *\n     * @return The token symbol.\n     */\n    function symbol() public view virtual override(ERC20) returns (string memory) {\n        return _symbol;\n    }\n}\n"
        },
        "src/Units.sol": {
            "content": "// SPDX-License-Identifier: LicenseRef-Uniteum\n\npragma solidity ^0.8.30;\n\nimport {Term} from \"./Term.sol\";\nimport {Rationals, Rational, Rational8} from \"./Rationals.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\n\n/**\n * @title Units\n * @dev Library for unit term operations.\n * Base unit terms are packed into uint:\n * The last two bytes (30, 31) are a rational exponent.\n * Symbolic terms have the first 30 bytes as the base symbol.\n * Address terms have the first byte = 1, and the next 20 bytes are an address.\n * +0......0|1.........................20|21................29|30...........31+\n * | Symbol                                                   |    Exponent   |\n * |----------------------------------------------------------| ± num / den   |\n * | Type=1 | Address [1..20]            | Reserved           |  int8 | uint8 |\n * +255................................96|95................16|15....8|7.....0+\n * Example 1: meter^2\\3\n * |6d 6574657200000000000000000000000000000000 000000000000000000 02 03|\n * |  |                                        |                  |  |  |\n * |01 c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 000000000000000000 ff 01|\n * Example 2: [address of WETH]^-1\n */\nlibrary Units {\n    using Units for *;\n    using Rationals for *;\n    using Strings for *;\n\n    /// @dev Bitmap indicating valid symbol characters: 0-9, A-Z, a-z, _, -, .\n    uint256 constant SYMBOL_CHAR_BITS = 0x7fffffe87fffffe03ff600000000000;\n    /// @dev The term for 1^0. The ascii code for \"1\" is 0x31.\n    /// @dev Shift amount for term type byte: 248 bits (31 bytes) = 0xf8\n    uint256 constant ONE_TERM = 0x31 << 0xf8;\n    /// @dev A term with this type is an encoded address reference with an exponent.\n    uint256 constant ANCHOR_TERM_TYPE = 1;\n    /// @dev Shift amount for anchor address: 20 bytes (address) + 9 bytes (reserved) = 88 bits = 0x58\n    uint256 constant ANCHOR_SHIFT = 0x58;\n    string constant ONE_SYMBOL = \"1\";\n    bytes1 constant ANCHOR_PREFIX = \"$\";\n    bytes1 constant DIVIDE_SYMBOL = \"/\";\n    bytes1 constant MULTIPLY_SYMBOL = \"*\";\n    bytes1 constant POWER_SYMBOL = \"^\";\n    bytes1 constant POWER_DIV = \"\\\\\"; // backslash escaped\n    Rational8 constant ZERO_RATIONAL_8 = Rational8.wrap(1);\n    Rational8 constant ONE_RATIONAL_8 = Rational8.wrap(0x101);\n    uint256 constant EXPONENT_MASK = 0xffff;\n    uint256 constant MAX_SYMBOL_SIZE = 30;\n\n    // Errors\n    error BaseSymbolTooBig();\n    error ExponentTooBig();\n    error InvalidAddressTerm(Term term);\n    error BadHexCharacter(uint8 char);\n    error UnexpectedCharacter(bytes1 char);\n    error UnexpectedEndOfInput();\n\n    /// @dev Extracts the base part from a term (clears the exponent byte)\n    function base(Term term) internal pure returns (Term base_) {\n        base_ = Term.wrap(term.raw() & ~uint256(EXPONENT_MASK));\n    }\n\n    function raw(Term term) internal pure returns (uint256) {\n        return Term.unwrap(term);\n    }\n\n    /// @dev Extracts the exponent from a term (int8 stored in lowest byte)\n    function exponent(Term term) internal pure returns (Rational8) {\n        return Rational8.wrap(int16(uint16(term.raw())));\n    }\n\n    /// @dev Returns whether the char is one of 0-9, A-Z, a-z, _, -, .\n    function isSymbolChar(bytes1 char) internal pure returns (bool) {\n        return (SYMBOL_CHAR_BITS >> uint8(char)) & 1 != 0;\n    }\n\n    function termType(Term term) internal pure returns (uint8 termType_) {\n        termType_ = uint8(term.raw() >> 0xf8);\n    }\n\n    function isBase(Term term) internal pure returns (bool) {\n        return term.exponent().raw() == ONE_RATIONAL_8.raw();\n    }\n\n    /**\n     * @notice Return the external token address represented by the term.\n     * @dev Return address(0) if the term is not an external token term.\n     */\n    function anchor(Term term) internal pure returns (address token) {\n        if (term.termType() == ANCHOR_TERM_TYPE && term.isBase()) {\n            // forge-lint: disable-next-line(unsafe-typecast)\n            token = address(uint160(term.raw() >> ANCHOR_SHIFT));\n        }\n    }\n\n    /**\n     * @notice Return the external token address represented by the terms.\n     * @dev Return address(0) if the term is not an external token term.\n     */\n    function anchor(Term[] memory terms) internal pure returns (address token) {\n        if (terms.length == 1) {\n            token = terms[0].anchor();\n        }\n    }\n\n    function parts(Term term)\n        internal\n        pure\n        returns (\n            uint256 bits,\n            bool isBase_,\n            uint8 termType_,\n            address tokenAddress_,\n            bytes30 symbol_,\n            int8 numerator_,\n            uint8 denominator_\n        )\n    {\n        bits = term.raw();\n        // forge-lint: disable-next-line(unsafe-typecast)\n        termType_ = uint8(bits >> 0xf8);\n        // forge-lint: disable-next-line(unsafe-typecast)\n        numerator_ = int8(uint8(bits >> 8));\n        // forge-lint: disable-next-line(unsafe-typecast)\n        denominator_ = uint8(bits);\n        isBase_ = numerator_ == 1 && denominator_ == 1;\n        if (termType_ != ANCHOR_TERM_TYPE) {\n            // forge-lint: disable-next-line(unsafe-typecast)\n            symbol_ = bytes30(uint240(bits >> 16));\n        } else if (isBase_) {\n            // forge-lint: disable-next-line(unsafe-typecast)\n            tokenAddress_ = address(uint160(bits >> ANCHOR_SHIFT));\n        }\n    }\n\n    /**\n     * @dev Reverts if the term is not valid\n     *      - has non-symbol characters before the zero padding\n     *      - has an exponent numerator = -128\n     */\n    function mustBeValidTerm(Term term) internal pure {\n        (uint256 c,, uint8 t,, bytes30 s, int8 n, uint8 d) = term.parts();\n        if (n == -128) {\n            revert ExponentTooBig();\n        }\n        if (d == 0) {\n            revert Rationals.ZeroDenominator();\n        }\n\n        if (t == ANCHOR_TERM_TYPE) {\n            if (0 != ((c >> 16) << 23 * 8)) {\n                revert InvalidAddressTerm(term);\n            }\n        } else {\n            uint256 i;\n            unchecked {\n                for (; i < 30; ++i) {\n                    if (!s[i].isSymbolChar()) {\n                        break;\n                    }\n                }\n\n                for (; i < 30; ++i) {\n                    if (s[i] != 0) {\n                        revert UnexpectedCharacter(s[i]);\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Revert if any term is invalid.\n    function mustBeValidTerms(Term[] memory terms) internal pure {\n        unchecked {\n            for (uint256 i = 0; i < terms.length; ++i) {\n                terms[i].mustBeValidTerm();\n            }\n        }\n    }\n\n    /// @dev Packs a base and exponent into a term\n    function withExponent(Term base_, Rational8 exp) internal pure returns (Term term) {\n        term = Term.wrap((base_.raw() & ~uint256(EXPONENT_MASK)) | uint256(uint16(int16(exp.raw()))));\n    }\n\n    /// @dev Packs a base and exponent into a term\n    function withExponent(address base_, Rational8 exp) internal pure returns (Term term) {\n        term = Term.wrap((uint256(uint160(base_)) << ANCHOR_SHIFT) | (ANCHOR_TERM_TYPE << 0xf8)).withExponent(exp);\n    }\n\n    /// @dev Return the reciprocal of a term (negates exponent)\n    function reciprocal(Term term) internal pure returns (Term reciprocal_) {\n        reciprocal_ = term.withExponent(term.exponent().neg());\n    }\n\n    /// @dev Return the reciprocal terms. Modifies the input.\n    function reciprocal(Term[] memory terms) internal pure returns (Term[] memory reciprocal_) {\n        reciprocal_ = terms;\n        unchecked {\n            for (uint256 i = 0; i < terms.length; ++i) {\n                reciprocal_[i] = terms[i].reciprocal();\n            }\n        }\n    }\n\n    /// @dev Concatenates three strings\n    function add(string memory s1, string memory s2, string memory s3) internal pure returns (string memory) {\n        return string.concat(s1, s2, s3);\n    }\n\n    function toString(bytes30 b) internal pure returns (string memory s) {\n        uint256 end;\n        unchecked {\n            // Find trailing zeros\n            for (; end < 30; ++end) {\n                if (b[end] == 0) {\n                    break;\n                }\n            }\n        }\n\n        bytes memory sb = new bytes(end);\n\n        unchecked {\n            for (uint256 i = 0; i < end; ++i) {\n                sb[i] = b[i];\n            }\n        }\n        s = string(sb);\n    }\n\n    /// @dev Returns the symbol string for a single term\n    function symbol(Term term) internal pure returns (string memory symbol_) {\n        (,, uint8 t, address a, bytes30 s, int8 n, uint8 d) = term.parts();\n        if (n == 0) {\n            return ONE_SYMBOL;\n        }\n        if (t == ANCHOR_TERM_TYPE) {\n            symbol_ = string.concat(\"$\", Strings.toChecksumHexString(a));\n        } else {\n            symbol_ = toString(s);\n        }\n        if (n != 1 || d != 1) {\n            symbol_ = symbol_.add(\"^\", Strings.toStringSigned(n));\n            if (d != 1) {\n                symbol_ = symbol_.add(\"\\\\\", Strings.toString(d));\n            }\n        }\n    }\n\n    /// @dev Returns the full compound unit symbol from an array of terms\n    function symbol(Term[] memory terms) internal pure returns (string memory symbol_) {\n        if (terms.length == 0) {\n            return ONE_SYMBOL;\n        }\n\n        string memory mul; // Do not put * before the first term\n        unchecked {\n            for (uint256 i = 0; i < terms.length; ++i) {\n                int256 n = terms[i].exponent().numerator();\n                if (n > 0) {\n                    symbol_ = symbol_.add(mul, terms[i].symbol());\n                    mul = \"*\";\n                }\n            }\n        }\n\n        if (bytes(symbol_).length == 0) {\n            symbol_ = ONE_SYMBOL;\n        }\n\n        unchecked {\n            for (uint256 i = 0; i < terms.length; ++i) {\n                int256 n = terms[i].exponent().numerator();\n                if (n < 0) {\n                    symbol_ = symbol_.add(\"/\", terms[i].reciprocal().symbol());\n                }\n            }\n        }\n    }\n\n    /// @dev Parses a base symbol starting at buffer[start], returns base-packed uint\n    function parseAddress(bytes memory buffer, uint256 start) internal pure returns (Term term, uint256 cursor) {\n        uint256 end = buffer.length;\n        cursor = start + 42;\n        cursor.mustBeLessThan(end + 1);\n        if (buffer[start] != \"0\") {\n            revert BadHexCharacter(uint8(buffer[start]));\n        }\n        if (buffer[start + 1] != \"x\") {\n            revert BadHexCharacter(uint8(buffer[start + 1]));\n        }\n        start += 2;\n        uint160 result = 0;\n        unchecked {\n            for (uint256 i = start; i < cursor; ++i) {\n                uint8 c = uint8(buffer[i]);\n                if (c >= 48 && c <= 57) {\n                    // '0'-'9'\n                    result = result * 16 + (c - 48);\n                } else if (c >= 65 && c <= 70) {\n                    // 'A'-'F'\n                    result = result * 16 + (c - 55);\n                } else if (c >= 97 && c <= 102) {\n                    // 'a'-'f'\n                    result = result * 16 + (c - 87);\n                } else {\n                    revert BadHexCharacter(c);\n                }\n            }\n        }\n        term = address(result).withExponent(ONE_RATIONAL_8);\n    }\n\n    /// @dev Parses a base symbol starting at buffer[start], returns base-packed uint\n    function parseBase(bytes memory buffer, uint256 start) internal pure returns (Term term, uint256 cursor) {\n        uint256 end = buffer.length;\n        cursor = start;\n\n        // Advance the cursor past symbol characters.\n        while (cursor < end && buffer[cursor].isSymbolChar()) {\n            cursor++;\n        }\n\n        uint256 baseLength = cursor - start;\n\n        if (baseLength > MAX_SYMBOL_SIZE) {\n            revert BaseSymbolTooBig();\n        }\n\n        // SAFETY: Reading from memory buffer at validated offset (start < cursor < end)\n        // and masking to exact baseLength bytes. No out-of-bounds access possible.\n        assembly {\n            let word := mload(add(add(buffer, 32), start))\n            let shift := sub(256, mul(baseLength, 8))\n            let mask := shl(shift, sub(exp(2, mul(baseLength, 8)), 1))\n            term := and(word, mask)\n        }\n    }\n\n    /// @dev Parse an integer starting at buffer[start].\n    function parseNumber(bytes memory buffer, uint256 start) internal pure returns (uint256 n, uint256 cursor) {\n        uint256 end = buffer.length;\n        cursor = start;\n        unchecked {\n            while (cursor < end && n <= 128 && buffer[cursor] >= \"0\" && buffer[cursor] <= \"9\") {\n                n = n * 10 + uint8(buffer[cursor]) - 48;\n                ++cursor;\n            }\n        }\n    }\n\n    /// @dev Reverts if cursor is not less than end\n    function mustBeLessThan(uint256 cursor, uint256 end) internal pure {\n        if (cursor >= end) {\n            revert UnexpectedEndOfInput();\n        }\n    }\n\n    /// @dev Parses a full compound symbol into an array of terms\n    function parseTerms(string memory symbol_) internal pure returns (Term[] memory terms) {\n        bytes memory buffer = bytes(symbol_);\n        uint256 end = buffer.length;\n        uint256 cursor = 0;\n\n        cursor.mustBeLessThan(end);\n\n        // Count number of terms\n        uint256 termCount = 1;\n        unchecked {\n            for (uint256 j = 1; j < end; ++j) {\n                if (buffer[j] == DIVIDE_SYMBOL || buffer[j] == MULTIPLY_SYMBOL) termCount++;\n            }\n        }\n\n        terms = new Term[](termCount);\n        uint256 termIndex = 0;\n\n        while (cursor < end) {\n            int256 exp = 1;\n\n            // Skip * or /\n            if (cursor > 0) {\n                if (buffer[cursor] == MULTIPLY_SYMBOL) {\n                    cursor++;\n                } else if (buffer[cursor] == DIVIDE_SYMBOL) {\n                    exp = -exp;\n                    cursor++;\n                }\n            }\n\n            cursor.mustBeLessThan(end);\n\n            Term term;\n            if (buffer[cursor] == ANCHOR_PREFIX) {\n                cursor++;\n                (term, cursor) = parseAddress(buffer, cursor);\n            } else {\n                (term, cursor) = parseBase(buffer, cursor);\n            }\n\n            if (term.raw() == 0) {\n                revert UnexpectedCharacter(cursor == end ? bytes1(0) : buffer[cursor]);\n            }\n\n            uint256 expDenom = 1;\n\n            // Extract exponent if present\n            if (cursor < end && buffer[cursor] == POWER_SYMBOL) {\n                cursor++;\n                cursor.mustBeLessThan(end);\n\n                uint256 pow = 0;\n                (pow, cursor) = parseNumber(buffer, cursor);\n                exp *= pow.toInt128();\n\n                if (cursor < end && buffer[cursor] == POWER_DIV) {\n                    cursor++;\n                    cursor.mustBeLessThan(end);\n                    (expDenom, cursor) = parseNumber(buffer, cursor);\n                }\n            }\n\n            Rational8 exp8 = exp.divRational8(expDenom);\n            term = term.withExponent(exp8);\n            terms[termIndex++] = term;\n        }\n    }\n\n    function toInt128(uint256 x) internal pure returns (int128 y) {\n        if (x <= uint128(type(int128).max)) {\n            // forge-lint: disable-next-line(unsafe-typecast)\n            y = int128(uint128(x));\n        } else {\n            revert ExponentTooBig();\n        }\n    }\n\n    /// @dev Returns first n terms from array\n    function take(Term[] memory long, uint256 n) internal pure returns (Term[] memory short) {\n        if (long.length == n) {\n            short = long;\n        } else {\n            short = new Term[](n);\n            unchecked {\n                for (uint256 i = 0; i < n; ++i) {\n                    short[i] = long[i];\n                }\n            }\n        }\n    }\n\n    /// @dev Merges two sorted term arrays\n    function product(Term[] memory t1, Term[] memory t2) internal pure returns (Term[] memory t3) {\n        uint256 n1 = t1.length;\n        uint256 n2 = t2.length;\n\n        if (n1 == 0) {\n            return t2;\n        }\n        if (n2 == 0) {\n            return t1;\n        }\n\n        t3 = new Term[](n1 + n2);\n        uint256 i1 = 0;\n        uint256 i2 = 0;\n        uint256 i3 = 0;\n\n        while (i1 < n1 && i2 < n2) {\n            Term base1 = t1[i1].base();\n            Term base2 = t2[i2].base();\n\n            if (base1.raw() < base2.raw()) {\n                t3[i3++] = t1[i1++];\n            } else if (base2.raw() < base1.raw()) {\n                t3[i3++] = t2[i2++];\n            } else {\n                // Same base, combine exponents\n                // Sum using int16 then check for too big.\n                Rational8 exp = t1[i1].exponent().add(t2[i2].exponent());\n                if (exp.raw() != ZERO_RATIONAL_8.raw()) {\n                    t3[i3++] = base1.withExponent(exp);\n                }\n                i1++;\n                i2++;\n            }\n        }\n\n        // Copy remaining terms\n        while (i1 < n1) {\n            t3[i3++] = t1[i1++];\n        }\n        while (i2 < n2) {\n            t3[i3++] = t2[i2++];\n        }\n\n        t3 = t3.take(i3);\n    }\n\n    /// @dev Determine if the terms are in order.\n    function inOrder(Term[] memory terms) internal pure returns (bool) {\n        uint256 n = terms.length;\n        if (n == 0) return true;\n\n        unchecked {\n            for (uint256 i = 0; i < n - 1; ++i) {\n                if (terms[i].raw() > terms[i + 1].raw()) return false;\n            }\n        }\n        return true;\n    }\n\n    /// @dev Sorts terms in ascending base order using heap sort\n    function sort(Term[] memory terms) internal pure returns (Term[] memory) {\n        if (terms.inOrder()) return terms;\n\n        uint256 n = terms.length;\n\n        // Build max heap\n        for (uint256 i = n / 2; i > 0; i--) {\n            heapify(terms, n, i - 1);\n        }\n\n        // Extract elements from heap one by one\n        for (uint256 i = n - 1; i > 0; i--) {\n            // Move current root to end\n            (terms[0], terms[i]) = (terms[i], terms[0]);\n            // call max heapify on the reduced heap\n            heapify(terms, i, 0);\n        }\n        return terms;\n    }\n\n    function heapify(Term[] memory terms, uint256 n, uint256 i) private pure {\n        uint256 largest = i;\n        uint256 left = 2 * i + 1;\n        uint256 right = 2 * i + 2;\n\n        if (left < n && terms[left].raw() > terms[largest].raw()) {\n            largest = left;\n        }\n        if (right < n && terms[right].raw() > terms[largest].raw()) {\n            largest = right;\n        }\n        if (largest != i) {\n            (terms[i], terms[largest]) = (terms[largest], terms[i]);\n            heapify(terms, n, largest);\n        }\n    }\n\n    /// @dev Sorts and merges duplicate bases\n    function sortAndMerge(Term[] memory terms) internal pure returns (Term[] memory) {\n        if (terms.length == 0) return terms;\n\n        terms = terms.sort();\n\n        // Quick check if merge is needed or if \"1\" terms need filtering\n        bool needsProcessing = false;\n        unchecked {\n            for (uint256 i = 0; i < terms.length; ++i) {\n                if (terms[i].base().raw() == ONE_TERM) {\n                    needsProcessing = true;\n                    break;\n                }\n                if (i > 0 && terms[i].base().raw() == terms[i - 1].base().raw()) {\n                    needsProcessing = true;\n                    break;\n                }\n            }\n        }\n        if (!needsProcessing) return terms;\n\n        uint256 termCount = terms.length;\n        uint256 j;\n        Term term = terms[0].base();\n        Rational exp = terms[0].exponent().toRational();\n        unchecked {\n            for (uint256 i = 1; i < termCount; ++i) {\n                if (terms[i].base().raw() == term.raw()) {\n                    exp = exp.add(terms[i].exponent().toRational());\n                } else {\n                    if (exp.raw() != ZERO_RATIONAL_8.raw() && term.raw() != ONE_TERM) {\n                        terms[j] = term.withExponent(exp.toRational8());\n                        ++j;\n                    }\n                    term = terms[i].base();\n                    exp = terms[i].exponent().toRational();\n                }\n            }\n            if (exp.raw() != ZERO_RATIONAL_8.raw() && term.raw() != ONE_TERM) {\n                terms[j] = term.withExponent(exp.toRational8());\n                ++j;\n            }\n        }\n\n        terms = terms.take(j);\n        return terms;\n    }\n}\n"
        },
        "lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
        },
        "lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/math/Math.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Return the 512-bit addition of two uint256.\n     *\n     * The result is stored in two 256 variables such that sum = high * 2²⁵⁶ + low.\n     */\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        assembly (\"memory-safe\") {\n            low := add(a, b)\n            high := lt(low, a)\n        }\n    }\n\n    /**\n     * @dev Return the 512-bit multiplication of two uint256.\n     *\n     * The result is stored in two 256 variables such that product = high * 2²⁵⁶ + low.\n     */\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = high * 2²⁵⁶ + low.\n        assembly (\"memory-safe\") {\n            let mm := mulmod(a, b, not(0))\n            low := mul(a, b)\n            high := sub(sub(mm, low), lt(mm, low))\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            success = c >= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a - b;\n            success = c <= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a * b;\n            assembly (\"memory-safe\") {\n                // Only true when the multiplication doesn't overflow\n                // (c / a == b) || (a == 0)\n                success := or(eq(div(c, a), b), iszero(a))\n            }\n            // equivalent to: success ? c : 0\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `DIV` opcode returns zero when the denominator is 0.\n                result := div(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `MOD` opcode returns zero when the denominator is 0.\n                result := mod(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Unsigned saturating addition, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryAdd(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\n     */\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (, uint256 result) = trySub(a, b);\n        return result;\n    }\n\n    /**\n     * @dev Unsigned saturating multiplication, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryMul(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (high == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return low / denominator;\n            }\n\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\n            if (denominator <= high) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [high low].\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                high := sub(high, gt(remainder, low))\n                low := sub(low, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly (\"memory-safe\") {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [high low] by twos.\n                low := div(low, twos)\n\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from high into low.\n            low |= high * twos;\n\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and high\n            // is no longer required.\n            result = low * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n            if (high >= 1 << n) {\n                Panic.panic(Panic.UNDER_OVERFLOW);\n            }\n            return (high << (256 - n)) | (low >> n);\n        }\n    }\n\n    /**\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1) ≡ 1 mod p`. As a consequence, we have `a * a**(p-2) ≡ 1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) < 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1) ≤ sqrt(a) < 2**e → (2**(e-1))² ≤ a < (2**e)² → 2**(2*e-2) ≤ a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) < 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\n            // This is going to be our x_0 (and ε_0)\n            xn = (3 * xn) >> 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\n            //              = ((x_n² + a) / (2 * x_n))² - a\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\n            //              = (x_n² - a)² / (2 * x_n)²\n            //              = ((x_n² - a) / (2 * x_n))²\n            //              ≥ 0\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\n            //         = | ε_n² / (2 * x_n) |\n            //         = ε_n² / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // ε_1 = ε_0² / | (2 * x_0) |\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\n            //     ≤ 2**(e-3) / 3\n            //     ≤ 2**(e-3-log2(3))\n            //     ≤ 2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\n            //         ≤ 2**(2*e-2*k) / 2**e\n            //         ≤ 2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\n\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\n            // ε_6 ≤ 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // If upper 8 bits of 16-bit half set, add 8 to result\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\n        // If upper 4 bits of 8-bit half set, add 4 to result\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\n\n        // Shifts value right by the current result and use it as an index into this lookup table:\n        //\n        // | x (4 bits) |  index  | table[index] = MSB position |\n        // |------------|---------|-----------------------------|\n        // |    0000    |    0    |        table[0] = 0         |\n        // |    0001    |    1    |        table[1] = 0         |\n        // |    0010    |    2    |        table[2] = 1         |\n        // |    0011    |    3    |        table[3] = 1         |\n        // |    0100    |    4    |        table[4] = 2         |\n        // |    0101    |    5    |        table[5] = 2         |\n        // |    0110    |    6    |        table[6] = 2         |\n        // |    0111    |    7    |        table[7] = 2         |\n        // |    1000    |    8    |        table[8] = 3         |\n        // |    1001    |    9    |        table[9] = 3         |\n        // |    1010    |   10    |        table[10] = 3        |\n        // |    1011    |   11    |        table[11] = 3        |\n        // |    1100    |   12    |        table[12] = 3        |\n        // |    1101    |   13    |        table[13] = 3        |\n        // |    1110    |   14    |        table[14] = 3        |\n        // |    1111    |   15    |        table[15] = 3        |\n        //\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\n        assembly (\"memory-safe\") {\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
        },
        "lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/TransientSlot.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/TransientSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/TransientSlot.js.\n\npragma solidity ^0.8.24;\n\n/**\n * @dev Library for reading and writing value-types to specific transient storage slots.\n *\n * Transient slots are often used to store temporary values that are removed after the current transaction.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n *  * Example reading and writing values using transient storage:\n * ```solidity\n * contract Lock {\n *     using TransientSlot for *;\n *\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\n *     bytes32 internal constant _LOCK_SLOT = 0xf4678858b2b588224636b8522b729e7722d32fc491da849ed75b3fdf3c84f542;\n *\n *     modifier locked() {\n *         require(!_LOCK_SLOT.asBoolean().tload());\n *\n *         _LOCK_SLOT.asBoolean().tstore(true);\n *         _;\n *         _LOCK_SLOT.asBoolean().tstore(false);\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {SlotDerivation}.\n */\nlibrary TransientSlot {\n    /**\n     * @dev UDVT that represents a slot holding an address.\n     */\n    type AddressSlot is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a AddressSlot.\n     */\n    function asAddress(bytes32 slot) internal pure returns (AddressSlot) {\n        return AddressSlot.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represents a slot holding a bool.\n     */\n    type BooleanSlot is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a BooleanSlot.\n     */\n    function asBoolean(bytes32 slot) internal pure returns (BooleanSlot) {\n        return BooleanSlot.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represents a slot holding a bytes32.\n     */\n    type Bytes32Slot is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Bytes32Slot.\n     */\n    function asBytes32(bytes32 slot) internal pure returns (Bytes32Slot) {\n        return Bytes32Slot.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represents a slot holding a uint256.\n     */\n    type Uint256Slot is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Uint256Slot.\n     */\n    function asUint256(bytes32 slot) internal pure returns (Uint256Slot) {\n        return Uint256Slot.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represents a slot holding a int256.\n     */\n    type Int256Slot is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Int256Slot.\n     */\n    function asInt256(bytes32 slot) internal pure returns (Int256Slot) {\n        return Int256Slot.wrap(slot);\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(AddressSlot slot) internal view returns (address value) {\n        assembly (\"memory-safe\") {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(AddressSlot slot, address value) internal {\n        assembly (\"memory-safe\") {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(BooleanSlot slot) internal view returns (bool value) {\n        assembly (\"memory-safe\") {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(BooleanSlot slot, bool value) internal {\n        assembly (\"memory-safe\") {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Bytes32Slot slot) internal view returns (bytes32 value) {\n        assembly (\"memory-safe\") {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Bytes32Slot slot, bytes32 value) internal {\n        assembly (\"memory-safe\") {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Uint256Slot slot) internal view returns (uint256 value) {\n        assembly (\"memory-safe\") {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Uint256Slot slot, uint256 value) internal {\n        assembly (\"memory-safe\") {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Int256Slot slot) internal view returns (int256 value) {\n        assembly (\"memory-safe\") {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Int256Slot slot, int256 value) internal {\n        assembly (\"memory-safe\") {\n            tstore(slot, value)\n        }\n    }\n}\n"
        },
        "lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
        },
        "src/IMigratable.sol": {
            "content": "// SPDX-License-Identifier: LicenseRef-Uniteum\n\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title IMigratable\n * @notice Interface for tokens that support migration from an upstream version.\n * @dev Tokens implementing this interface can accept upstream tokens and issue\n *      an equivalent amount of this token in exchange.\n */\ninterface IMigratable {\n    /**\n     * @notice Upstream 1 token this contract accepts for migration.\n     * @dev Circulating supply is conserved across all migrations.\n     * @dev The most upstream 1 will not be an IUnit.\n     * @return upstream token this contract accepts for migration.\n     */\n    function UPSTREAM() external view returns (IERC20 upstream);\n\n    /**\n     * @notice Migrate upstream tokens to this token.\n     * @dev The caller must approve this contract to transfer the upstream tokens.\n     *      The upstream tokens are transferred from the caller to this contract,\n     *      and an equivalent amount of this token is minted/transferred to the caller.\n     * @param amount The number of tokens to migrate.\n     */\n    function migrate(uint256 amount) external;\n\n    /**\n     * @notice Reverse migrate this token to its upstream token.\n     * @dev The caller's tokens are burned/transferred to this contract,\n     *      and an equivalent amount of upstream tokens is transferred to the caller.\n     * @param amount The number of tokens to reverse migrate.\n     */\n    function unmigrate(uint256 amount) external;\n\n    /**\n     * @notice Emitted when tokens are migrated from upstream to downstream.\n     * @param upstream The upstream token address (source).\n     * @param downstream The downstream token address (destination).\n     * @param amount The number of tokens migrated.\n     */\n    event Migrated(address indexed upstream, address indexed downstream, uint256 amount);\n\n    /**\n     * @notice Emitted when tokens are reverse migrated from downstream to upstream.\n     * @param upstream The upstream token address (destination).\n     * @param downstream The downstream token address (source).\n     * @param amount The number of tokens reverse migrated.\n     */\n    event Unmigrated(address indexed upstream, address indexed downstream, uint256 amount);\n}\n"
        },
        "src/Prototype.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\n\n/**\n * @title Prototype\n * @notice Base contract for self-cloning minimal proxy implementations using EIP-1167.\n * @dev\n * The contract deployed as the Prototype acts as:\n *   - the reference implementation with canonical logic, and\n *   - a factory that deterministically deploys minimal proxy clones of itself.\n *\n * Each clone:\n *   - delegates all logic to the Prototype via DELEGATECALL,\n *   - maintains its own isolated storage,\n *   - preserves the original msg.sender through the proxy,\n *   - inherits the same immutable PROTOTYPE address.\n *\n * **Deterministic Deployment:**\n * All clones are deployed with CREATE2 using salts derived from initialization\n * data via keccak256(abi.encode(initData)), ensuring predictable, repeatable\n * addresses. Calling __clone with identical initData will return the same\n * address without redeploying.\n *\n * **Usage Pattern:**\n * 1. Deploy Prototype implementation contract\n * 2. Call __clone(initData) to create instances\n * 3. Each clone is automatically initialized via __initialize(initData)\n * 4. Clones can call __clone to create more clones (forwarded to Prototype)\n *\n * @author Paul Reinholdtsen (reinholdtsen.eth)\n */\nabstract contract Prototype {\n    // ============ State Variables ============\n\n    /**\n     * @notice Address of the original Prototype implementation.\n     * @dev Clones inherit this immutable value through bytecode; on the Prototype\n     *      itself it equals address(this). This creates a shared reference point\n     *      for all clones to delegate calls to and query state from.\n     *\n     *      Immutables are embedded in bytecode during deployment, so each clone's\n     *      bytecode contains the Prototype address even though storage is separate.\n     */\n    address internal immutable PROTOTYPE = address(this);\n\n    /**\n     * @dev Registry mapping clone addresses to their CREATE2 salts.\n     *      Only populated on the Prototype contract, not on clones.\n     *\n     *      Maps: clone address → CREATE2 salt\n     *\n     *      A non-zero value indicates the address was deployed as a valid clone.\n     *      Used by isClone() for verification and to prevent duplicate deployments.\n     */\n    mapping(address => bytes32) private salts;\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Returns true if `check` is a clone of this Prototype.\n     * @dev When called on the Prototype: checks the salts registry directly.\n     *      When called on a clone: delegates to the Prototype for verification.\n     *\n     *      This pattern ensures a single source of truth (the Prototype's registry)\n     *      while allowing verification from any context.\n     *\n     * @param check Address to examine.\n     * @return yes True if the address was deployed as a clone via __clone().\n     */\n    function isClone(address check) public view returns (bool yes) {\n        yes = address(this) == PROTOTYPE ? salts[check] != 0x0 : Prototype(PROTOTYPE).isClone(check);\n    }\n\n    /**\n     * @notice Returns the immutable Prototype address.\n     * @dev Identical for both the implementation and all clones because it reads\n     *      from the immutable PROTOTYPE field embedded in bytecode.\n     *\n     *      Useful for:\n     *      - Accessing the canonical registry (salts mapping)\n     *      - Delegating operations back to the implementation\n     *      - Verifying clone authenticity\n     *\n     * @return The address of the Prototype implementation contract.\n     */\n    function prototype() public view returns (address) {\n        return PROTOTYPE;\n    }\n\n    /**\n     * @notice Predicts the clone address for a given salt.\n     * @dev Uses OpenZeppelin's Clones library to compute the deterministic address\n     *      based on the Prototype address and salt. This is a view function that\n     *      does not deploy anything.\n     *\n     *      The address is computed as: CREATE2(PROTOTYPE, salt, PROTOTYPE, initcode)\n     *      where the deployer is the Prototype itself.\n     *\n     * @param newSalt The CREATE2 salt that will be used.\n     * @return predicted The deterministic clone address that would be deployed.\n     */\n    function __predict(bytes32 newSalt) public view returns (address predicted) {\n        predicted = Clones.predictDeterministicAddress(PROTOTYPE, newSalt, PROTOTYPE);\n    }\n\n    /**\n     * @notice Predicts the clone address for initialization data.\n     * @dev Salt is deterministically derived from initData as:\n     *      keccak256(abi.encode(initData))\n     *\n     *      Note: abi.encode is used (not abi.encodePacked) to ensure proper\n     *      ABI encoding with type information, preventing collisions.\n     *\n     *      This overload is the primary entry point for predicting addresses\n     *      when you have initialization parameters but not a precomputed salt.\n     *\n     * @param initData Initialization calldata for the clone.\n     * @return predicted Deterministic clone address.\n     * @return newSalt The CREATE2 salt derived from initData.\n     */\n    function __predict(bytes memory initData) public view returns (address predicted, bytes32 newSalt) {\n        newSalt = keccak256(abi.encode(initData));\n        predicted = __predict(newSalt);\n    }\n\n    // ============ Factory Functions ============\n\n    /**\n     * @notice Deploys a deterministic minimal proxy clone.\n     * @dev\n     * **When called on the Prototype:**\n     *   1. Computes salt from keccak256(abi.encode(initData))\n     *   2. Predicts clone address using CREATE2 formula\n     *   3. If no code at address: deploys clone, records salt, calls __initialize\n     *   4. If code exists: returns existing address (idempotent)\n     *   5. Calls __initialize(initData) on newly deployed clones only\n     *\n     * **When called on a clone:**\n     *   - Forwards the request back to PROTOTYPE.__clone(initData)\n     *   - This enables clones to create other clones transparently\n     *\n     * **Idempotency:**\n     * Calling __clone with the same initData multiple times returns the same\n     * address. Only the first call performs deployment and initialization.\n     *\n     * **Security:**\n     * Only the Prototype can call __initialize due to onlyPrototype modifier.\n     * Clones cannot initialize themselves or other clones directly.\n     *\n     * @param initData Initialization data passed to the clone's __initialize.\n     * @return instance The deployed (or existing) clone address.\n     * @return newSalt The CREATE2 salt used for deterministic deployment.\n     */\n    function __clone(bytes memory initData) public returns (address instance, bytes32 newSalt) {\n        if (address(this) == PROTOTYPE) {\n            (instance, newSalt) = __predict(initData);\n\n            if (instance.code.length == 0) {\n                instance = Clones.cloneDeterministic(PROTOTYPE, newSalt);\n                salts[instance] = newSalt;\n                Prototype(instance).__initialize(initData);\n            }\n        } else {\n            (instance, newSalt) = Prototype(PROTOTYPE).__clone(initData);\n        }\n    }\n\n    /**\n     * @notice Initialize a newly deployed clone.\n     * @dev **Must be implemented by derived classes.**\n     *\n     *      **Security considerations:**\n     *      - MUST use the onlyPrototype modifier to prevent unauthorized calls\n     *      - SHOULD validate initData to prevent malicious initialization\n     *      - SHOULD consider using a reentrancy guard if calling external contracts\n     *      - MUST NOT assume msg.sender is the end user (it's always PROTOTYPE)\n     *\n     *      **Initialization pattern:**\n     *      Decode initData, set storage variables, emit events. The actual user\n     *      who called __clone is typically encoded in initData, not msg.sender.\n     *\n     *      **Called automatically** by __clone during clone deployment.\n     *\n     * @param initData ABI-encoded initialization parameters.\n     */\n    function __initialize(bytes memory initData) public virtual;\n\n    // ============ Internal Functions ============\n\n    /**\n     * @notice Restricts calls to the Prototype implementation contract only.\n     * @dev Applied to __initialize to ensure only the Prototype can initialize\n     *      new clones during deployment. Prevents external actors or clones\n     *      themselves from calling initialization logic.\n     *\n     *      Uses internal _onlyPrototype() for the actual check.\n     */\n    modifier onlyPrototype() {\n        _onlyPrototype();\n        _;\n    }\n\n    /**\n     * @dev Reverts if msg.sender is not the Prototype implementation.\n     *\n     *      This check ensures that only the factory (Prototype) can call\n     *      protected functions, preventing unauthorized initialization or\n     *      configuration of clones.\n     *\n     *      Reverts with Unauthorized() custom error for gas efficiency.\n     */\n    function _onlyPrototype() internal view {\n        if (msg.sender != PROTOTYPE) {\n            revert Unauthorized();\n        }\n    }\n\n    // ============ Errors ============\n\n    /**\n     * @notice Error raised when a caller lacks permission to execute a protected function.\n     * @dev Thrown by the onlyPrototype modifier when msg.sender != PROTOTYPE.\n     *      Custom errors are more gas-efficient than require strings.\n     */\n    error Unauthorized();\n}\n"
        },
        "lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
        },
        "src/Term.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\n/**\n * @title Term — Unit Term Type\n * @dev Type for unit term operations.\n * Base unit terms are packed into uint:\n * The last two bytes (30, 31) are a rational exponent.\n * Symbolic terms have the first 30 bytes as the base symbol.\n * Address terms have the first byte = 1, and the next 20 bytes are an address.\n * +0......0|1.........................20|21................29|30...........31+\n * | Symbol                                                   |    Exponent   |\n * |----------------------------------------------------------| ± num / den   |\n * | Type=1 | Address [1..20]            | Reserved           |  int8 | uint8 |\n * +255................................96|95................16|15....8|7.....0+\n * Example 1: meter^2\\3\n * |6d 6574657200000000000000000000000000000000 000000000000000000 02 03|\n * |  |                                        |                  |  |  |\n * |01 c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 000000000000000000 ff 01|\n * Example 2: [address of WETH]^-1\n */\ntype Term is uint256;\n"
        },
        "src/Rationals.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Rational, Rational8} from \"./Rational.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\n\n/**\n * @title Rationals\n * @notice Library for rational number arithmetic with 128-bit and 8-bit representations\n * @dev Rational: int256 with high 128 bits = numerator, low 128 bits = denominator\n *      Rational8: int16 with high 8 bits = numerator, low 8 bits = denominator\n *      All rationals are stored in reduced form (lowest terms)\n */\nlibrary Rationals {\n    int128 constant NUMERATOR_MAX = type(int128).max;\n    uint128 constant DENOMINATOR_MAX = type(uint128).max;\n    int8 constant NUMERATOR8_MAX = type(int8).max;\n    uint8 constant DENOMINATOR8_MAX = type(uint8).max;\n\n    using Rationals for *;\n    using Strings for *;\n\n    /**\n     * @dev Reverts when a denominator is zero\n     */\n    error ZeroDenominator();\n\n    /**\n     * @dev Reverts when a value cannot safely downcast to a smaller type\n     */\n    error ExponentTooBig();\n    error DenominatorTooBig();\n    error NumeratorTooBig();\n\n    /**\n     * @dev Reverts when exact Rat16 encoding is impossible\n     */\n    error Rat16EncodingImpossible();\n\n    /**\n     * @notice Unwraps a Rational to its underlying int256 representation\n     */\n    function raw(Rational n) internal pure returns (int256) {\n        return Rational.unwrap(n);\n    }\n\n    /**\n     * @notice Unwraps a Rational8 to its underlying int16 representation\n     */\n    function raw(Rational8 n) internal pure returns (int256) {\n        return Rational8.unwrap(n);\n    }\n\n    /**\n     * @notice Decodes a Ratio128 value into numerator and denominator\n     * @param a A Ratio128-encoded int value\n     * @return n Signed 128-bit numerator\n     * @return d Unsigned 128-bit denominator\n     */\n    function parts(Rational a) internal pure returns (int256 n, uint256 d) {\n        int256 r = a.raw();\n        n = r >> 128;\n        // forge-lint: disable-next-line(unsafe-typecast)\n        d = uint256(r) & DENOMINATOR_MAX;\n    }\n\n    /**\n     * @notice Encodes a numerator and denominator as a Rational, reduced to lowest terms\n     * @param n Signed 128-bit numerator\n     * @param d Unsigned 128-bit denominator (must be nonzero)\n     * @return a Encoded Rational value in reduced form\n     */\n    function divRational(int256 n, uint256 d) internal pure returns (Rational a) {\n        if (d == 0) {\n            revert ZeroDenominator();\n        }\n\n        uint256 g = gcd(_abs(n), d);\n        // forge-lint: disable-next-line(unsafe-typecast)\n        n /= int128(uint128(g));\n        // forge-lint: disable-next-line(unsafe-typecast)\n        d /= uint128(g);\n\n        if (n < -NUMERATOR_MAX || NUMERATOR_MAX < n) {\n            revert NumeratorTooBig();\n        }\n\n        if (d > DENOMINATOR_MAX) {\n            revert DenominatorTooBig();\n        }\n\n        // forge-lint: disable-next-line(unsafe-typecast)\n        a = Rational.wrap((n << 128) | int256(uint256(d)));\n    }\n\n    /**\n     * @notice Negates a Ratio128-encoded value\n     * @param a A Ratio128-encoded int value\n     * @return Negated Ratio128-encoded value\n     */\n    function neg(Rational a) internal pure returns (Rational) {\n        (int256 n, uint256 d) = a.parts();\n        return (-n).divRational(d);\n    }\n\n    /**\n     * @notice Adds two Rational values and returns normalized result\n     * @dev Computes a/b + c/d by finding common denominator using LCM\n     */\n    function add(Rational a, Rational b) internal pure returns (Rational) {\n        (int256 an, uint256 ad) = a.parts();\n        (int256 bn, uint256 bd) = b.parts();\n        uint256 gd = gcd(ad, bd);\n        // forge-lint: disable-next-line(divide-before-multiply)\n        uint256 d = (ad / gd) * bd;\n        // forge-lint: disable-next-line(unsafe-typecast)\n        int256 n = an * int256(d / ad) + bn * int256(d / bd);\n\n        return n.divRational(d);\n    }\n\n    /**\n     * @notice Subtracts two Rational values and returns normalized result\n     * @dev Computes a - b as a + (-b)\n     */\n    function sub(Rational a, Rational b) internal pure returns (Rational) {\n        return a.add(b.neg());\n    }\n\n    /**\n     * @notice Multiplies two Rational values and returns normalized result\n     * @dev Computes (a/b) * (c/d) = (a*c)/(b*d), then reduces using GCD\n     */\n    function mul(Rational a, Rational b) internal pure returns (Rational) {\n        (int256 an, uint256 ad) = a.parts();\n        (int256 bn, uint256 bd) = b.parts();\n        int256 n = int256(an) * int256(bn);\n        uint256 d = uint256(ad) * uint256(bd);\n        uint256 g = gcd(uint256(_abs(n)), d);\n        return (n / g.toInt256()).divRational(d / g);\n    }\n\n    /**\n     * @notice Divides Rational a by Rational b and returns normalized result\n     * @dev Computes (a/b) / (c/d) = (a*d)/(b*c), handling sign normalization\n     */\n    function div(Rational a, Rational b) internal pure returns (Rational r) {\n        (int256 an, uint256 ad) = a.parts();\n        (int256 bn, uint256 bd) = b.parts();\n        if (bn == 0) {\n            revert ZeroDenominator();\n        }\n        int256 n = an * bd.toInt256();\n        int256 d = ad.toInt256() * bn;\n        if (d < 0) {\n            n = -n;\n            d = -d;\n        }\n        // forge-lint: disable-next-line(unsafe-typecast)\n        r = n.divRational(uint256(d));\n    }\n\n    /**\n     * @notice Extracts the numerator from a Rational8 value\n     */\n    function numerator(Rational8 a8) internal pure returns (int256 n) {\n        n = int8(a8.raw() >> 8);\n    }\n\n    /**\n     * @notice Extracts the denominator from a Rational8 value\n     */\n    function denominator(Rational8 a8) internal pure returns (uint256 d) {\n        d = uint8(uint256(a8.raw()));\n    }\n\n    /**\n     * @notice Decodes a Rational8 value into numerator and denominator\n     * @param a A Rational8-encoded int value\n     * @return n Signed 8-bit numerator\n     * @return d Unsigned 8-bit denominator\n     */\n    function parts(Rational8 a) internal pure returns (int8 n, uint8 d) {\n        int256 r = a.raw();\n        // forge-lint: disable-next-line(unsafe-typecast)\n        n = int8(r >> 8);\n        // forge-lint: disable-next-line(unsafe-typecast)\n        d = uint8(uint256(r) & DENOMINATOR8_MAX);\n    }\n\n    /**\n     * @notice Encodes a numerator and denominator as a Rational8, reduced to lowest terms\n     * @param n Signed 8-bit numerator\n     * @param d Unsigned 8-bit denominator (must be nonzero)\n     * @return a Rational8 value in reduced form\n     */\n    function divRational8(int256 n, uint256 d) internal pure returns (Rational8 a) {\n        if (d == 0) {\n            revert ZeroDenominator();\n        }\n\n        uint256 g = gcd(_abs(n), d);\n        // forge-lint: disable-next-line(unsafe-typecast)\n        n /= int8(uint8(g));\n        // forge-lint: disable-next-line(unsafe-typecast)\n        d /= uint8(g);\n\n        if (n < -NUMERATOR8_MAX || n > NUMERATOR8_MAX) {\n            revert ExponentTooBig();\n        }\n        if (d > DENOMINATOR8_MAX) {\n            revert ExponentTooBig();\n        }\n        // forge-lint: disable-next-line(unsafe-typecast)\n        int256 encoded = (n << 8) | int256(uint256(d));\n        // forge-lint: disable-next-line(unsafe-typecast)\n        a = Rational8.wrap(int16(encoded));\n    }\n\n    /**\n     * @notice Negates a Rational8-encoded value\n     * @param a A Rational8-encoded int16 value\n     * @return Negated Rational8-encoded value\n     */\n    function neg(Rational8 a) internal pure returns (Rational8) {\n        (int8 n, uint8 d) = a.parts();\n        return divRational8(-n, d);\n    }\n\n    /**\n     * @notice Adds two Rational8 values by converting to Rational, adding, then converting back\n     */\n    function add(Rational8 a, Rational8 b) internal pure returns (Rational8) {\n        return a.toRational().add(b.toRational()).toRational8();\n    }\n\n    /**\n     * @notice Converts a Rational to an exact Rational8, reverts if not representable\n     */\n    function toRational8(Rational a) internal pure returns (Rational8 a8) {\n        (int256 n, uint256 d) = a.parts();\n        a8 = n.divRational8(d);\n    }\n\n    /**\n     * @notice Converts a Rational8 value to Rational\n     */\n    function toRational(Rational8 a8) internal pure returns (Rational a) {\n        (int256 n, uint256 d) = a8.parts();\n        a = n.divRational(d);\n    }\n\n    /**\n     * @notice Safely converts uint256 to int256, reverting on overflow\n     */\n    function toInt256(uint256 x) internal pure returns (int256 y) {\n        if (x <= uint256(type(int256).max)) {\n            // forge-lint: disable-next-line(unsafe-typecast)\n            y = int256(uint256(x));\n        } else {\n            revert ExponentTooBig();\n        }\n    }\n\n    /**\n     * @notice Computes greatest common divisor using Euclidean algorithm\n     */\n    function gcd(uint256 a, uint256 b) public pure returns (uint256) {\n        while (b != 0) {\n            uint256 t = b;\n            b = a % b;\n            a = t;\n        }\n        return a;\n    }\n\n    /**\n     * @notice Computes least common multiple of two denominators\n     * @dev Uses identity lcm(a, b) = (a / gcd(a, b)) * b\n     */\n    function lcm(uint256 a, uint256 b) public pure returns (uint256) {\n        // forge-lint: disable-next-line(divide-before-multiply)\n        return (a / gcd(a, b)) * b;\n    }\n\n    /**\n     * @notice Returns the absolute value of an int256\n     * @dev Handles type(int256).min safely using unchecked negation\n     */\n    function _abs(int256 x) internal pure returns (uint256) {\n        if (x >= 0) {\n            // forge-lint: disable-next-line(unsafe-typecast)\n            return uint256(x);\n        } else {\n            unchecked {\n                // forge-lint: disable-next-line(unsafe-typecast)\n                return uint256(-x);\n            }\n        }\n    }\n}\n"
        },
        "lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Strings.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SafeCast} from \"./math/SafeCast.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    using SafeCast for *;\n\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    uint256 private constant SPECIAL_CHARS_LOOKUP =\n        (1 << 0x08) | // backspace\n            (1 << 0x09) | // tab\n            (1 << 0x0a) | // newline\n            (1 << 0x0c) | // form feed\n            (1 << 0x0d) | // carriage return\n            (1 << 0x22) | // double quote\n            (1 << 0x5c); // backslash\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev The string being parsed contains characters that are not in scope of the given base.\n     */\n    error StringsInvalidChar();\n\n    /**\n     * @dev The string being parsed is not a properly formatted address.\n     */\n    error StringsInvalidAddressFormat();\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly (\"memory-safe\") {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly (\"memory-safe\") {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its checksummed ASCII `string` hexadecimal\n     * representation, according to EIP-55.\n     */\n    function toChecksumHexString(address addr) internal pure returns (string memory) {\n        bytes memory buffer = bytes(toHexString(addr));\n\n        // hash the hex part of buffer (skip length + 2 bytes, length 40)\n        uint256 hashValue;\n        assembly (\"memory-safe\") {\n            hashValue := shr(96, keccak256(add(buffer, 0x22), 40))\n        }\n\n        for (uint256 i = 41; i > 1; --i) {\n            // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)\n            if (hashValue & 0xf > 7 && uint8(buffer[i]) > 96) {\n                // case shift by xoring with 0x20\n                buffer[i] ^= 0x20;\n            }\n            hashValue >>= 4;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input) internal pure returns (uint256) {\n        return parseUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        uint256 result = 0;\n        for (uint256 i = begin; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 9) return (false, 0);\n            result *= 10;\n            result += chr;\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `int256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input) internal pure returns (int256) {\n        return parseInt(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input, uint256 begin, uint256 end) internal pure returns (int256) {\n        (bool success, int256 value) = tryParseInt(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that returns false if the parsing fails because of an invalid character or if\n     * the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(string memory input) internal pure returns (bool success, int256 value) {\n        return _tryParseIntUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    uint256 private constant ABS_MIN_INT256 = 2 ** 255;\n\n    /**\n     * @dev Variant of {parseInt-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character or if the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, int256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseIntUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseInt-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseIntUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, int256 value) {\n        bytes memory buffer = bytes(input);\n\n        // Check presence of a negative sign.\n        bytes1 sign = begin == end ? bytes1(0) : bytes1(_unsafeReadBytesOffset(buffer, begin)); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        bool positiveSign = sign == bytes1(\"+\");\n        bool negativeSign = sign == bytes1(\"-\");\n        uint256 offset = (positiveSign || negativeSign).toUint();\n\n        (bool absSuccess, uint256 absValue) = tryParseUint(input, begin + offset, end);\n\n        if (absSuccess && absValue < ABS_MIN_INT256) {\n            return (true, negativeSign ? -int256(absValue) : int256(absValue));\n        } else if (absSuccess && negativeSign && absValue == ABS_MIN_INT256) {\n            return (true, type(int256).min);\n        } else return (false, 0);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input) internal pure returns (uint256) {\n        return parseHexUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseHexUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseHexUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string-uint256-uint256} that returns false if the parsing fails because of an\n     * invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseHexUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseHexUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseHexUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        // skip 0x prefix if present\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(buffer, begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 offset = hasPrefix.toUint() * 2;\n\n        uint256 result = 0;\n        for (uint256 i = begin + offset; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 15) return (false, 0);\n            result *= 16;\n            unchecked {\n                // Multiplying by 16 is equivalent to a shift of 4 bits (with additional overflow check).\n                // This guarantees that adding a value < 16 will not cause an overflow, hence the unchecked.\n                result += chr;\n            }\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as an `address`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input) internal pure returns (address) {\n        return parseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input, uint256 begin, uint256 end) internal pure returns (address) {\n        (bool success, address value) = tryParseAddress(input, begin, end);\n        if (!success) revert StringsInvalidAddressFormat();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that returns false if the parsing fails because the input is not a properly\n     * formatted address. See {parseAddress-string} requirements.\n     */\n    function tryParseAddress(string memory input) internal pure returns (bool success, address value) {\n        return tryParseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string-uint256-uint256} that returns false if the parsing fails because input is not a properly\n     * formatted address. See {parseAddress-string-uint256-uint256} requirements.\n     */\n    function tryParseAddress(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, address value) {\n        if (end > bytes(input).length || begin > end) return (false, address(0));\n\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(bytes(input), begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 expectedLength = 40 + hasPrefix.toUint() * 2;\n\n        // check that input is the correct length\n        if (end - begin == expectedLength) {\n            // length guarantees that this does not overflow, and value is at most type(uint160).max\n            (bool s, uint256 v) = _tryParseHexUintUncheckedBounds(input, begin, end);\n            return (s, address(uint160(v)));\n        } else {\n            return (false, address(0));\n        }\n    }\n\n    function _tryParseChr(bytes1 chr) private pure returns (uint8) {\n        uint8 value = uint8(chr);\n\n        // Try to parse `chr`:\n        // - Case 1: [0-9]\n        // - Case 2: [a-f]\n        // - Case 3: [A-F]\n        // - otherwise not supported\n        unchecked {\n            if (value > 47 && value < 58) value -= 48;\n            else if (value > 96 && value < 103) value -= 87;\n            else if (value > 64 && value < 71) value -= 55;\n            else return type(uint8).max;\n        }\n\n        return value;\n    }\n\n    /**\n     * @dev Escape special characters in JSON strings. This can be useful to prevent JSON injection in NFT metadata.\n     *\n     * WARNING: This function should only be used in double quoted JSON strings. Single quotes are not escaped.\n     *\n     * NOTE: This function escapes all unicode characters, and not just the ones in ranges defined in section 2.5 of\n     * RFC-4627 (U+0000 to U+001F, U+0022 and U+005C). ECMAScript's `JSON.parse` does recover escaped unicode\n     * characters that are not in this range, but other tooling may provide different results.\n     */\n    function escapeJSON(string memory input) internal pure returns (string memory) {\n        bytes memory buffer = bytes(input);\n        bytes memory output = new bytes(2 * buffer.length); // worst case scenario\n        uint256 outputLength = 0;\n\n        for (uint256 i; i < buffer.length; ++i) {\n            bytes1 char = bytes1(_unsafeReadBytesOffset(buffer, i));\n            if (((SPECIAL_CHARS_LOOKUP & (1 << uint8(char))) != 0)) {\n                output[outputLength++] = \"\\\\\";\n                if (char == 0x08) output[outputLength++] = \"b\";\n                else if (char == 0x09) output[outputLength++] = \"t\";\n                else if (char == 0x0a) output[outputLength++] = \"n\";\n                else if (char == 0x0c) output[outputLength++] = \"f\";\n                else if (char == 0x0d) output[outputLength++] = \"r\";\n                else if (char == 0x5c) output[outputLength++] = \"\\\\\";\n                else if (char == 0x22) {\n                    // solhint-disable-next-line quotes\n                    output[outputLength++] = '\"';\n                }\n            } else {\n                output[outputLength++] = char;\n            }\n        }\n        // write the actual length and deallocate unused memory\n        assembly (\"memory-safe\") {\n            mstore(output, outputLength)\n            mstore(0x40, add(output, shl(5, shr(5, add(outputLength, 63)))))\n        }\n\n        return string(output);\n    }\n\n    /**\n     * @dev Reads a bytes32 from a bytes array without bounds checking.\n     *\n     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the\n     * assembly block as such would prevent some optimizations.\n     */\n    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\n        assembly (\"memory-safe\") {\n            value := mload(add(buffer, add(0x20, offset)))\n        }\n    }\n}\n"
        },
        "lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
        },
        "lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/interfaces/IERC1363.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
        },
        "lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Panic.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
        },
        "lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
        },
        "lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/proxy/Clones.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.20;\n\nimport {Create2} from \"../utils/Create2.sol\";\nimport {Errors} from \"../utils/Errors.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[ERC-1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n */\nlibrary Clones {\n    error CloneArgumentsTooLong();\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        return clone(implementation, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-clone-address-}[clone], but with a `value` parameter to send native currency\n     * to the new contract.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function clone(address implementation, uint256 value) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        assembly (\"memory-safe\") {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(value, 0x09, 0x37)\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple times will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        return cloneDeterministic(implementation, salt, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-cloneDeterministic-address-bytes32-}[cloneDeterministic], but with\n     * a `value` parameter to send native currency to the new contract.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function cloneDeterministic(\n        address implementation,\n        bytes32 salt,\n        uint256 value\n    ) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        assembly (\"memory-safe\") {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(value, 0x09, 0x37, salt)\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := and(keccak256(add(ptr, 0x43), 0x55), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation` with custom\n     * immutable arguments. These are provided through `args` and cannot be changed after deployment. To\n     * access the arguments within the implementation, use {fetchCloneArgs}.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function cloneWithImmutableArgs(address implementation, bytes memory args) internal returns (address instance) {\n        return cloneWithImmutableArgs(implementation, args, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-cloneWithImmutableArgs-address-bytes-}[cloneWithImmutableArgs], but with a `value`\n     * parameter to send native currency to the new contract.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function cloneWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        uint256 value\n    ) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\n        assembly (\"memory-safe\") {\n            instance := create(value, add(bytecode, 0x20), mload(bytecode))\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation` with custom\n     * immutable arguments. These are provided through `args` and cannot be changed after deployment. To\n     * access the arguments within the implementation, use {fetchCloneArgs}.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy the clone. Using the same\n     * `implementation`, `args` and `salt` multiple times will revert, since the clones cannot be deployed twice\n     * at the same address.\n     */\n    function cloneDeterministicWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        return cloneDeterministicWithImmutableArgs(implementation, args, salt, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Clones-cloneDeterministicWithImmutableArgs-address-bytes-bytes32-}[cloneDeterministicWithImmutableArgs],\n     * but with a `value` parameter to send native currency to the new contract.\n     *\n     * NOTE: Using a non-zero value at creation will require the contract using this function (e.g. a factory)\n     * to always have enough balance for new deployments. Consider exposing this function under a payable method.\n     */\n    function cloneDeterministicWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt,\n        uint256 value\n    ) internal returns (address instance) {\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\n        return Create2.deploy(value, salt, bytecode);\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministicWithImmutableArgs}.\n     */\n    function predictDeterministicAddressWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\n        return Create2.computeAddress(salt, keccak256(bytecode), deployer);\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministicWithImmutableArgs}.\n     */\n    function predictDeterministicAddressWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddressWithImmutableArgs(implementation, args, salt, address(this));\n    }\n\n    /**\n     * @dev Get the immutable args attached to a clone.\n     *\n     * - If `instance` is a clone that was deployed using `clone` or `cloneDeterministic`, this\n     *   function will return an empty array.\n     * - If `instance` is a clone that was deployed using `cloneWithImmutableArgs` or\n     *   `cloneDeterministicWithImmutableArgs`, this function will return the args array used at\n     *   creation.\n     * - If `instance` is NOT a clone deployed using this library, the behavior is undefined. This\n     *   function should only be used to check addresses that are known to be clones.\n     */\n    function fetchCloneArgs(address instance) internal view returns (bytes memory) {\n        bytes memory result = new bytes(instance.code.length - 45); // revert if length is too short\n        assembly (\"memory-safe\") {\n            extcodecopy(instance, add(result, 32), 45, mload(result))\n        }\n        return result;\n    }\n\n    /**\n     * @dev Helper that prepares the initcode of the proxy with immutable args.\n     *\n     * An assembly variant of this function requires copying the `args` array, which can be efficiently done using\n     * `mcopy`. Unfortunately, that opcode is not available before cancun. A pure solidity implementation using\n     * abi.encodePacked is more expensive but also more portable and easier to review.\n     *\n     * NOTE: https://eips.ethereum.org/EIPS/eip-170[EIP-170] limits the length of the contract code to 24576 bytes.\n     * With the proxy code taking 45 bytes, that limits the length of the immutable args to 24531 bytes.\n     */\n    function _cloneCodeWithImmutableArgs(\n        address implementation,\n        bytes memory args\n    ) private pure returns (bytes memory) {\n        if (args.length > 24531) revert CloneArgumentsTooLong();\n        return\n            abi.encodePacked(\n                hex\"61\",\n                uint16(args.length + 45),\n                hex\"3d81600a3d39f3363d3d373d3d3d363d73\",\n                implementation,\n                hex\"5af43d82803e903d91602b57fd5bf3\",\n                args\n            );\n    }\n}\n"
        },
        "lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Context.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
        },
        "lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/interfaces/draft-IERC6093.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
        },
        "src/Rational.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.30;\n\ntype Rational is int256;\ntype Rational8 is int16;\n"
        },
        "lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, int256 a, int256 b) internal pure returns (int256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // Formula from the \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\n            // taking advantage of the most significant (or \"sign\" bit) in two's complement representation.\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\n            // the mask will either be `bytes32(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\n            int256 mask = n >> 255;\n\n            // A `bytes32(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\n            return uint256((n + mask) ^ mask);\n        }\n    }\n}\n"
        },
        "lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
        },
        "lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
        },
        "lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Create2.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Create2.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev There's no code to deploy.\n     */\n    error Create2EmptyBytecode();\n\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n        if (bytecode.length == 0) {\n            revert Create2EmptyBytecode();\n        }\n        assembly (\"memory-safe\") {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n            // if no address was created, and returndata is not empty, bubble revert\n            if and(iszero(addr), not(iszero(returndatasize()))) {\n                let p := mload(0x40)\n                returndatacopy(p, 0, returndatasize())\n                revert(p, returndatasize())\n            }\n        }\n        if (addr == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   | ↓ ptr ...  ↓ ptr + 0x0B (start) ...  ↓ ptr + 0x20 ...  ↓ ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |            ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := and(keccak256(start, 85), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n    }\n}\n"
        },
        "lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Errors.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
        },
        "lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
        }
    },
    "settings": {
        "remappings": [
            "forge-std/=lib/forge-std/src/",
            "@openzeppelin/contracts/=lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/",
            "@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
            "erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/",
            "halmos-cheatcodes/=lib/openzeppelin-contracts-upgradeable/lib/halmos-cheatcodes/src/",
            "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/",
            "openzeppelin-contracts/=lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/",
            "openzeppelin-foundry-upgrades/=lib/openzeppelin-foundry-upgrades/src/"
        ],
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "metadata": {
            "useLiteralContent": false,
            "bytecodeHash": "ipfs",
            "appendCBOR": true
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "evm.bytecode.object",
                    "evm.bytecode.sourceMap",
                    "evm.bytecode.linkReferences",
                    "evm.deployedBytecode.object",
                    "evm.deployedBytecode.sourceMap",
                    "evm.deployedBytecode.linkReferences",
                    "evm.deployedBytecode.immutableReferences",
                    "evm.methodIdentifiers",
                    "metadata"
                ]
            }
        },
        "evmVersion": "cancun",
        "viaIR": true,
        "debug": {
            "revertStrings": "default"
        },
        "libraries": {}
    }
}